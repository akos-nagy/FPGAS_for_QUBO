%\documentclass[reqno,12pt]{amsart}

%%%%%%%%%% todo stuff %%%%%%%%%%

\documentclass[reqno,oneside,12pt]{amsart}  % for todos

\usepackage[textwidth=0.9in]{todonotes}
\reversemarginpar
\setuptodonotes{fancyline,color=blue!40,size=\tiny}
\setlength{\marginparwidth}{0.8in}

%%%%%%%%%% Packages %%%%%%%%%%

\usepackage{amsmath,bbm,verbatim,wasysym,nicefrac}
%mathtools,appendix,soul,ulem,slashed,upgreek
\usepackage[protrusion=true, babel=true]{microtype}
\usepackage[english]{babel}
\usepackage[widespace]{fourier}
\usepackage[backrefs]{amsrefs}
\usepackage[margin=1in]{geometry}
\usepackage[onehalfspacing]{setspace}
\usepackage[pdfusetitle,pagebackref]{hyperref}
\numberwithin{equation}{section}                % must be called before cleveref
\usepackage[nameinlink,noabbrev]{cleveref}
\expandafter\def\csname ver@etex.sty\endcsname{3000/12/31}
\let\globcount\newcount
\usepackage{autonum}                            % must be called after cleveref
\usepackage{tikz}
\usetikzlibrary{quantikz}

%%%%%%%%%% align break fix %%%%%%%%%%

\allowdisplaybreaks[1]

%%%%%%%%%% Left/Right fix %%%%%%%%%%

\let\originalleft\left
\let\originalright\right
\renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}
\renewcommand{\right}{\aftergroup\egroup\originalright}

\def\({\mathopen{}\left(}
\def\){\right)\mathclose{}}

%%%%%%%%%% eqref fix %%%%%%%%%%

\makeatletter
\renewcommand*{\eqref}[1]{\hyperref[{#1}]{\textup{\tagform@{\ref*{#1}}}}}
\makeatother

%%%%%%%%%% oxford comma fix %%%%%%%%%%

\newcommand{\creflastconjunction}{, and\nobreakspace}

%%%%%%%%%% formula definitions %%%%%%%%%%

\newcommand*{\eqdef}{\mathrel{\vcenter{\baselineskip0.5ex \lineskiplimit0pt\hbox{.}\hbox{.}}}=}
\newcommand*{\defeq}{=\mathrel{\vcenter{\baselineskip0.5ex \lineskiplimit0pt\hbox{.}\hbox{.}}}}

%%%%%%%%%% Theorems/numbering %%%%%%%%%%

\newtheorem*{acknowledgment}{Acknowledgments}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{hypothesis}[theorem]{Hypothesis}
\newtheorem{example}[theorem]{Example}
\crefname{theorem}{Theorem}{Theorems}                 % label for Theorems
\creflabelformat{theorem}{#2{#1}#3}                   % label format for theorem
\crefname{main}{Main Theorem}{Main Theorems}          % label for the Main Theorems
\creflabelformat{main}{#2{#1}#3}                   % label format for main
\crefname{lemma}{Lemma}{Lemmas}                       % label for Lemmas
\creflabelformat{lemma}{#2{#1}#3}                     % label format for lem
\crefname{corollary}{Corollary}{Corollaries}          % label for Corollaries
\creflabelformat{corollary}{#2{#1}#3}                 % label format for cor
\crefname{ineq}{inequality}{inequalities}             % label for inequalities
\creflabelformat{ineq}{#2{\upshape(#1)}#3}               % label format for ineq
\crefname{diag}{diagram}{diagrams}             % label for diagrams
\creflabelformat{diag}{#2{\upshape(#1)}#3}               % label format for diag
\crefname{cond}{condition}{conditions}                % label for conditions
\creflabelformat{cond}{#2{#1}#3}                   % label format for cond
\crefname{table}{Table}{Tables}                       % label for Tables
\creflabelformat{table}{#2{\upshape(#1)}#3}              % label format for Tables
\crefname{hypothesis}{Hypothesis}{Hypotheses}            % label for Hypotheses
\creflabelformat{hypothesis}{#2{#1}#3}                % label format for Hypotheses
\crefname{remark}{Remark}{Remarks}                    % label for Remarks
\creflabelformat{remark}{#2{#1}#3}                    % label format for Remarks
\crefname{definition}{Definition}{Definitions}           % label for Definitions
\creflabelformat{def}{#2{#1}#3}                       % label format for 'def'

%%%%%%%%%% Blackboard %%%%%%%%%%

\def\id{\mathbbm{1}}
\def\cx{\mathbbm{C}}
\def\bG{\mathbbm{G}}
\def\rl{\mathbbm{R}}
\def\N{\mathbbm{N}}
\def\P{\mathbbm{P}}
\def\Z{\mathbbm{Z}}

%%%%%%%%%% CalligraPhics %%%%%%%%%%

\def\cA{\mathcal{A}}
\def\cB{\mathcal{B}}
\def\cC{\mathcal{C}}
\def\cD{\mathcal{D}}
\def\cE{\mathcal{E}}
\def\cF{\mathcal{F}}
\def\cG{\mathcal{G}}
\def\cH{\mathcal{H}}
\def\cI{\mathcal{I}}
\def\cK{\mathcal{K}}
\def\cL{\mathcal{L}}
\def\cM{\mathcal{M}}
\def\cN{\mathcal{N}}
\def\cO{\mathcal{O}}
\def\cP{\mathcal{P}}
\def\cR{\mathcal{R}}
\def\cS{\mathcal{S}}
\def\cT{\mathcal{T}}
\def\cU{\mathcal{U}}
\def\cV{\mathcal{V}}
\def\cW{\mathcal{W}}
\def\cZ{\mathcal{Z}}

%%%%%%%%%% Romans %%%%%%%%%%

\def\ad{\mathrm{ad}}
\def\Ad{\mathrm{Ad}}
\def\Aut{\mathrm{Aut}}
\def\coker{\mathrm{coker}}
\def\rd{\mathrm{d}}
\def\diag{\mathrm{diag}}
\def\dist{\mathrm{dist}}
\def\Div{\mathrm{Div}}
\def\dom{\mathrm{dom}}
\def\End{\mathrm{End}}
\def\rG{\mathrm{G}}
\def\Hom{\mathrm{Hom}}
\def\Im{\mathrm{Im}}
\def\image{\mathrm{image}}
\def\index{\mathrm{index}}
\def\Isom{\mathrm{Isom}}
\def\Lie{\mathrm{Lie}}
\def\PU{\mathrm{PU}}
\def\rk{\mathrm{rk}}
\def\Re{\mathrm{Re}}
\def\Res{\mathrm{Res}}
\def\sign{\mathrm{sign}}
\def\SL{\mathrm{SL}}
\def\SO{\mathrm{SO}}
\def\Sp{\mathrm{Sp}}
\def\Spec{\mathrm{Spec}}
\def\spn{\mathrm{span}}
\def\Spin{\mathrm{Spin}}
\def\Sym{\mathrm{Sym}}
\def\SU{\mathrm{SU}}
\def\supp{\mathrm{supp}}
\def\tr{\mathrm{tr}}

%%%%%%%%%% Other symbols (paper specific) %%%%%%%%%%

\def\qdict{\textsc{qdict}}
\def\QFT{\mathrm{QFT}}

%%%%%%%%%% Other formatting %%%%%%%%%%

\title{(Adaptive) Grover Fixed-point Search for Binary Optimization Problems}
\date{\today}
\keywords{Grover Fixed-point Search, Binary Optimization}
%\subjclass[2020]{}

\author{Atithi Acharya}
\address[Atithi Acharya]{}

\author{\'Akos Nagy}
\address[\'Akos Nagy]{Department of Mathematics, University of California, Santa Barbara}
\urladdr{\href{https://akosnagy.com/}{akosnagy.com}}
\email{\href{mailto:contact@akosnagy.com}{contact@akosnagy.com}}

\author{Jaime Park}
\address[Jaime Park]{}

\author{Cindy Zhang}
\address[Cindy Zhang]{}

\hypersetup{
   unicode        = true,
   pdffitwindow   = true,
   pdftoolbar     = false,
   pdfmenubar     = false,
   pdfstartview   = {FitH},
   hypertexnames  = true,
   colorlinks     = true,
   linkcolor      = black,
   citecolor      = black,
   filecolor      = black,
   urlcolor       = blue
}

\calclayout
\pagestyle{plain}
\clubpenalty = 10000
\widowpenalty = 10000
\setlength{\footskip}{20pt}

\hyphenation{}

\begin{document}

\begin{abstract}
	\textit{to be completed later...}
\end{abstract}

\maketitle

\section{Introduction}

\todo{to be completed later...}

\smallskip

\subsection*{Organization of the paper:} \todo{to be completed later...}

\begin{comment}
\smallskip

\begin{acknowledgment}
   
\end{acknowledgment}
\end{comment}

\bigskip

\section{(Polynomial Unconstrained) Binary Optimization}
\label{sec:qubos}

For the rest of the paper, $\Z_2^n$ denotes the space of length-$n$ bitstrings. Given a function $f : \Z_2^n \rightarrow \rl$, the associated (Unconstrained) Binary Optimization problem is the task of finding an element $x \in \Z_2^n$ such that $f (x)$ is maximal. Note that every binary function is polynomial, which can be seen by simple dimension count.

Many interesting Binary Optimization problems, such as finding maximal graph cuts or the Max $2$-SAT problems are quadratic, and most of the contemporary research centers around Quadratic Unconstrained  Binary Optimization (QUBO) problems. Hence, while our results and circuit designs apply to any binary functions, we use QUBO problems as examples. Furthermore, dealing with higher degree problems require more complicated circuits which makes them more prone to noise (and thus are less NISQ-y).

\medskip

\subsection{Quantum Dictionaries}
\label{sec:qdicts}

The first main contribution of the paper is an oracle design for encoding operators of (arbitrary) \emph{quantum dictionaries}, as introduced in \cite{gilliam_foundational_2021}. While such designs have already existed, cf. \cite{gilliam_grover_2021}, ours has improved circuit depth, gate count, and CNOT count. Such oracles have applications, for example, in Grover type algorithms and threshold-QAOA \cite{golden_threshold_2021}.

Briefly, the quantum dictionary, corresponding to a function (thought of as a classical dictionary), $F: \dom \( F \) \rightarrow \Z_2^m$, where $\dom \( F \) \subseteq \Z_2^n$, is the following quantum state on $n + m$ qubits:
\begin{equation}
   \ket{\qdict \( F \)} \eqdef \tfrac{1}{\sqrt{\left| \dom \( F \) \right|}} \sum\limits_{x \in \dom \( F \)} \ket{x}_n \ket{F (x)}_m.
\end{equation}
Note that an integer-valued function $f : \Z_n^2 \rightarrow \Z$ canonically determines a quantum dictionary via first defining $F (x)$ to be the digits of $f (x)$, then setting, by a slight abuse of notation, $\ket{\qdict \( f \)} = \ket{\qdict \( F \)}$. We handle signs via the ``Two's complement'' convention, in particular, a binary number $x_0 x_1 \ldots x_{m - 1}$ is negative exactly when $x_0 = 1$. In fact, every quantum dictionary can be realized in such a way. Since rational-valued functions can be handled similarly and real-valued functions can be approximated to arbitrary precision by rational ones, this construction can be used to encode (approximate) values of of arbitrary binary functions which, in \Cref{sec:grover_for_qubo}, we use to give a concrete implementation of the Grover Fixed-point search for QUBO problems.

We construct these operators in three steps. First, we outline a modified version of the encoding operator given in \cite{gilliam_grover_2021} that is convenient to encode monomials, $x_{i_1} x_{i_2} \cdots x_{i_j}$. Then we show that every binary function can be rewritten in a basis of functions that can be more efficiently encoded then monomials. Finally, we modify the encoding operators of \cite{gilliam_grover_2021} to apply for our new basis.

\medskip

\subsection{Polynomial encoder}
\label{sec:poly}

Let $I \subseteq \{ 1, 2, \ldots, n - 1 \}$ and $x_I \eqdef x_{i_1} x_{i_2} \cdots x_{i_j}$ be an arbitrary monomial and consider a quantum circuit with $m + n$ registers. Following \cite{gilliam_grover_2021}, we construct an oracle that sends $\ket{x}_n \ket{0}_m$ to $\ket{x}_n \ket{x_I}_m$, for any $x \in \Z_2^n$.

Let us make two definitions: Let $\QFT_m$ be the Quantum Fourier Transform on $m$ qubits, that is for any $- 2^{m - 1} \leqslant y < 2^{m - 1}$, we have
\begin{equation}
   \QFT_m \ket{y}_m = 2^{- \frac{m}{2}} \sum\limits_{z = - 2^{m - 1}}^{2^{m - 1} - 1} e^{\frac{2 \pi y z}{2^m} i} \ket{z}_m.
\end{equation}
Then
\begin{equation}
   \QFT_m^\dagger \ket{z}_m = 2^{- \frac{m}{2}} \sum\limits_{y^\prime = - 2^{m - 1}}^{2^{m - 1} - 1} e^{- \frac{2 \pi y^\prime z}{2^m} i} \ket{y^\prime}_m.
\end{equation}
Now let $\cP_m (k)$ be the following $m$-qubit gate
\begin{equation}
   \begin{quantikz}
      \lstick{\ket{z_0}} \qw  &  \gate{\textsc{phase} \( \pi k \)} & \qw \rstick{$ e^{\frac{2 \pi k z_0 2^{m - 1}}{2^m} i} \ket{z_1}$} \\
      \vdots \\
      \lstick{\ket{z_j}} \qw  &  \gate{\textsc{phase} \( \tfrac{2 \pi k}{2^{j + 1}} \)} & \qw \rstick{$ e^{\frac{2 \pi z_j 2^{m - j - 1}}{2^m}} \ket{z_j}$} \\
      \vdots \\
      \lstick{\ket{z_{m - 1}}} \qw  &  \gate{\textsc{phase} \( \tfrac{2 \pi k}{2^m} \)} & \qw \rstick{$ e^{\frac{2 \pi k z_{m - 1}}{2^m} i} \ket{z_m}$}
   \end{quantikz}   
\end{equation}
Thus $\cP_m \( k \) \ket{z}_m = e^{\frac{2 \pi k z}{2^m} i} \ket{z}_m$.

Now we can prove a well-known lemma. {\color{red} citation needed}

\begin{lemma}
   \label{lemma:quantum_adder}
   For any $- 2^{m - 1} \leqslant y < 2^{m - 1}$ and $k \in \Z$ we have
   \begin{equation}
      \QFT_m^\dagger \circ \cP_m \( k \) \circ \QFT_m \ket{y}_m = \ket{y + k \mod 2^{m - 1}}.
   \end{equation}
\end{lemma}

\begin{proof}
   First we compute
   \begin{align}
      \cP_m \( k \) \circ \QFT_m \ket{y}_m  &= \cP \( k \) \( 2^{- \frac{m}{2}} \sum\limits_{z = - 2^{m - 1}}^{2^{m - 1} - 1} e^{\frac{2 \pi y z}{2^m} i} \ket{z}_m \) \\
         &= 2^{- \frac{m}{2}} \sum\limits_{z = - 2^{m - 1}}^{2^{m - 1} - 1} e^{\frac{2 \pi y z}{2^m} i} \cP \( k \) \ket{z}_m \\
         &= 2^{- \frac{m}{2}} \sum\limits_{z = - 2^{m - 1}}^{2^{m - 1} - 1} e^{\frac{2 \pi \( y + k \) z}{2^m} i} \ket{z}_m \\
         &= \QFT_m \ket{y + k \mod 2^{m - 1}},
   \end{align}
   hence
   \begin{equation}
      \QFT_m^\dagger \circ \cP \( k \) \circ \QFT_m \ket{y}_m = \ket{y + k \mod 2^{m - 1}}.
   \end{equation}
\end{proof}

By \Cref{lemma:quantum_adder} it is immediate that
\begin{equation}
   \begin{quantikz}
      \lstick{$\ket{x}_n$}   & \qw  & \qw             & \qw & \ctrl{1}                & \qw & \qw                    & \qw \rstick{$\ket{x}_n$} \\
      \lstick{$\ket{0}_m$}   & \qw  & \gate{\QFT_m}   & \qw & \gate{C_I \cP \( 1 \)}  & \qw & \gate{\QFT_m^\dagger}  & \qw \rstick{$\ket{x_I}_m$}
   \end{quantikz}
\end{equation}
is the desired oracle, where $C_I$ means control by the quantum registers $i_1, i_2, \ldots i_j$.

Finally, to create the full quantum dictionary, $\ket{\qdict \( f \)}$, we need to pre-compose an oracle, call $U$, for which we have
\begin{equation}
   U \ket{0}_n = \tfrac{1}{\sqrt{\left| \dom \( f \) \right|}} \sum\limits_{x \in \dom \( f \)} \ket{x}_n.
\end{equation}
If $\dom \( f \) = \Z_2^n$, then $U = H^{\otimes n}$.
\begin{example}
   Let $n = m = 2$ and $f (x) = x_0 x_1$. Now the encoder oracle takes the form
   \begin{equation}
      \begin{quantikz}
         \lstick{$\ket{0}$}   & \qw  & \gate[2]{U}    & \qw & \ctrl{1} \gategroup[4, steps=3, style={dashed, rounded corners, fill=blue!20}, background, label style={label position=below, anchor=north, yshift=-1em}]{$C_I \cP \( 1 \)$}                          & \qw & \ctrl{2}                                   & \qw                    & \qw \rstick[4]{$\ket{\qdict \( f \)}$} \\
         \lstick{$\ket{0}$}   & \qw  &                & \qw & \ctrl{1}                          & \qw & \ctrl{2}                                   & \qw                    & \qw \\
         \lstick{$\ket{0}$}   & \qw  & \gate[2]{\QFT_2} & \qw & \gate{\textsc{phase} \( \pi \)}   & \qw & \qw                                        & \gate[2]{\QFT_2^\dagger} & \qw \\
         \lstick{$\ket{0}$}   & \qw  &                & \qw & \qw                               & \qw & \gate{\textsc{phase} \( \nicefrac{\pi}{2} \)}   &                        & \qw
      \end{quantikz}
   \end{equation}
\end{example}

\smallskip

For the rest of the paper we assume that $\dom \( f \) = \Z_2^n$ and thus $U = H^{\otimes n}$. Furthermore, we note that $\QFT_m \ket{0}_m = H^{\otimes m} \ket{0}_m$ and thus we replace $\QFT_m$ with $H^{\otimes m}$ in the oracle, as the latter has depth $1$ and uses only single-qubit gates.

Let $\P_n$ be the power set of $\{ 0, 1, \ldots, n - 1\}$. Now, for an arbitrary polynomial,
\begin{equation}
   f (x) = \sum\limits_{I \in \P_n} A_I x^I,
\end{equation}
and $m \in \Z$ large enough so that all values of $f$ can be digitized on $m$ bits, we have that
\begin{equation}
   \begin{quantikz}
      \lstick{$\ket{0}_n$}   & \qw  & \gate[2]{H^{\otimes (n + m)}}        & \qw & \ctrl{1} \gategroup[2, steps=1, style={dashed, rounded corners, fill=blue!20}, background, label style={label position=below, anchor=north, yshift=-1em}]{one for each $I \in \P_n$ with $A_I \neq 0$}                   & \qw \ \ldots \ & \qw & \qw                   & \qw \rstick[2]{$\ket{\qdict \( f \)}$} \\
      \lstick{$\ket{0}_m$}   & \qw  & & \qw & \gate{C_I \cP \( A_I \)}   & \qw \ \ldots \ & \qw & \gate{\QFT_m^\dagger} & \qw
   \end{quantikz}
\end{equation}

\medskip

\subsection{New basis for polynomials}
\label{sec:xor_basis}

We motivate the idea of the new basis by outlining it in the $n = 2$ case.

\smallskip

Note first that, since $x_i^2 = x_i$ for binary variables, we have that $x_0 x_1 = \tfrac{1}{2} \( x_0 + x_1 - \( x_0 - x_1 \)^2 \)$. Now $\( x_0 - x_1 \)^2$ is also a binary variable, in fact, $\( x_0 - x_1 \)^2 = x_0 \mathrm{XOR} x_1$. Now let $f$ be a generic polynomial, $f (x) = a_1 x_1$

\bigskip

\section{Grover Fixed-point search for QUBO}
\label{sec:grover_for_qubo}

\newpage

{\color{red} Everything below is old stuff that I might or might not want to include.}

\noindent\textbf{Input:} A symmetric, integer-valued, $n$-by-$n$ matrix, $Q$ and a constant $c \in \Z$, or, equivalently, a quadratic function on $x \in \{ 0, 1 \}^n$ given by
\begin{equation}
   f (x) \eqdef x^T Q x + c. \label{eq:QUBO}
\end{equation}
(Note that since $x_i^2 = x_i$, we can move linear terms into the diagonal of $Q$.)

\smallskip

\noindent\textbf{Output:} An estimate for the value
\begin{equation}
   M \eqdef \max \( \left\{ \ f (x) \ \middle| \ x \in \{ 0, 1 \}^n \ \right\} \).
\end{equation}

\medskip

\begin{example}[Maximal Graph Cuts]
   Given a simple, undirected graph, $G = \( V, E \)$, let $Q$ be its graph Laplacian, defined as
   \begin{equation}
      Q_{i, j} = \left\{ \begin{array}{ll} \deg \( v_i \), & \mbox{if } i = j, \\ - 1, & \mbox{if } \{ v_i, v_j \} \in E, \\ 0, & \mbox{otherwise,} \end{array} \right.
   \end{equation}
   $b = 0$ and $c = 0$. Then $V = V^+ \coprod V^-$ is a maximal exactly when $\mathrm{MaxCut} (G) = f(x) = M$, where $x \in \{ 0, 1 \}^n$ is defined as $x_i = 1$ if $v_i \in V^+$ and zero otherwise.

   The Edwards--Erd\H{o}s bound yields
   \begin{equation}
      \mathrm{MaxCut} (G) \geqslant B_G \eqdef \left\{ \begin{array}{ll} \frac{2 |V| + |E| - 1}{4}, & \mbox{if (we know that) $G$ is connected,} \\ \frac{|V|}{2} + \sqrt{\tfrac{|V|}{8} + \tfrac{1}{64}} - \frac{1}{8}, & \mbox{otherwise.} \end{array} \right.
   \end{equation}
\end{example}

\bigskip

\section{The oracles:}

An element $x = \( x_1, x_2, \ldots, x_n \) \in \{ 0, 1 \}^n$ is also regarded as a binary number via $x \sim \overline{x_1 x_2 \ldots x_n} \eqdef \sum_i x_i 2^{n - i}$ and as an element of the computational basis via
\begin{equation}
   \ket{x}_n \eqdef \ket{x_1} \ldots \ket{x_{n - 1}} \ket{x_n},
\end{equation}
Given a function as in \cref{eq:QUBO}, let us pick $m \gg \log_2 \( M \)$ (in fact, $m = \left\lceil \log_2 \( \tr \( Q \) \) \right\rceil + 1$ works for our purposes). We use the binary 2’s complement convention when digitizing integers and we with that in mind, we construct a oracle on $\( n + m \)$-qubits, $U_f$, so that
\begin{equation}
   U_f \ket{x}_n \ket{y}_m = \ket{x}_n \ket{y - f (x)}_m.
\end{equation}
Note that the $\( n + 1 \)^{\mathrm{th}}$ register of $U_f \ket{x}_n \ket{y}_m$ is $\ket{1}$ exactly when $y < f (x)$.

\medskip

\section{Application to Grover fixed point search and state preparation}

Fix $\delta \in \( 0, 1 \)$ and $y$. Let $\lambda \eqdef \tfrac{\left| C_y \right|}{2^n}$, where $C_y \eqdef \left\{ x \in \{ 0, 1 \}^n \middle| f (x) \geqslant y \right\}$. Finally let $l \eqdef \left\lceil \tfrac{\log_2 \( \tfrac{2}{\delta} \)}{2 \sqrt{\lambda}} - \tfrac{1}{2} \right\rceil$. Then, following \cite{yoder_fixed-point_2014}, we can construct a Quantum circuit (using $U_f$ from the previous section), that results in a state $S_l \ket{0}_n \ket{y}_m$ with the following significance: When the first $n$ qubits are measured in the computational basis, then
\begin{equation}
   P \( x \in C_y \) = \sum_{x \in C_y} \left| \bra{x} S_l \ket{0} \right|^2 \geqslant 1 - \delta^2.
\end{equation}

Let us make the following definitions:
\begin{align}
   U_S                     &\eqdef H^{\otimes n} \otimes \id^{\otimes m}, \\
   R_0 \( \alpha \)        &\eqdef \id^{\otimes (n + m)} + \( 1 - e^{i \alpha} \) \ket{0}_n \bra{0}_n \otimes \id^{\otimes (1 + m)}, \\
   R_T \( \beta \)         &\eqdef U_f^\dagger P_{n + 1} \( \beta \) U_f, \\
   G \( \alpha, \beta \)   &\eqdef - U_S R_0 \( \alpha \) U_S^\dagger R_T \( \beta \).
\end{align}
Let $\( \pmb{\alpha}, \pmb{\beta} \) = \( \alpha_1, \beta_1, \cdots, \alpha_l, \beta_l \)$ be given by
\begin{equation}
   \forall j \in \{ 1, \ldots, l \}: \quad \alpha_j \eqdef - \beta_{l - j + 1} = 2 \cot^{- 1} \( \tan \( \tfrac{2 \pi j}{2 l + 1} \) \sqrt{1 - \gamma^2} \),
\end{equation}
where $\gamma \eqdef \( T_{\nicefrac{1}{\( 2 l + 1\)}} \( \delta^{- 1} \) \)^{- 1}$
and let
\begin{equation}
   S_l \( \pmb{\alpha}, \pmb{\beta} \) = G \( \alpha_l, \beta_l \) G \( \alpha_{l - 1}, \beta_{l - 1} \) \cdots G \( \alpha_1, \beta_1 \) U_S. \label{eq:S_l-def}
\end{equation}





   %========================
   \bibliography{references}
   %========================

\end{document}